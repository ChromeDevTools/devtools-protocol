import * as fs from 'fs'
import * as path from 'path'
import {IProtocol, Protocol as P} from './protocol-schema'

// TODO: @noj validate this via https://github.com/andischerer/typescript-json-typesafe against protocol-schema.d.ts
import * as jsProtocol from '../json/js_protocol.json'
import * as browserProtocol from '../json/browser_protocol.json'


// TODO: @noj clean this up
interface ClientDef {
    name: string
    client: P.FunctionType
}

type ParamOrFunction = P.ParameterType | P.FunctionType

let numIndents = 0
let emitStr = ""

const emit = (str: string) => {
    emitStr += str
}

const emitIndent = () => {
    for (let i = 0; i < numIndents; ++i) {
        emitStr += "    " // 4 spaced indents
    }
}

const emitLine = (str = "") => {
    if (str) {
        emitIndent()
        emit(`${str}\n`)
    } else {
        emit("\n")
    }
}

const emitOpenBlock = (str: string, openChar = ' {') => {
    emitLine(`${str}${openChar}`)
    numIndents++
}

const emitCloseBlock = (closeChar = '}') => {
    numIndents--
    emitLine(closeChar)
}

const emitHeaderComments = () => {
    emitLine("/**********************************************************************")
    emitLine(" * Auto-generated by protocol-dts-generator.ts, do not edit manually. *")
    emitLine(" **********************************************************************/")
    emitLine()
}

const emitModule = (moduleName:string, domains: P.Domain[]) => {
    moduleName = toTitleCase(moduleName)
    emitHeaderComments()
    emitOpenBlock(`export namespace ${moduleName}`)
    emitGlobalTypeDefs()
    emitInterface(`${moduleName}Api`, domains.map(d => getDomainDef(d.domain, 'Api')))
    domains.forEach(emitDomain)
    emitCloseBlock()
    emitLine()
    emitLine(`export default ${moduleName};`)
}

const emitGlobalTypeDefs = () => {
    emitLine()
    emitLine(`export type integer = number`)
}

const emitDomain = (domain: P.Domain) => {
    const domainName = toTitleCase(domain.domain)
    emitLine()
    emitDescription(domain.description)
    emitOpenBlock(`export namespace ${domainName}`)
    domain.types ? domain.types.forEach(emitType) : null
    const commandDefs = domain.commands ? domain.commands.map(c => emitCommand(c, domainName)) : []
    const eventDefs = domain.events ? domain.events.map(e => emitEvent(e, domainName)) : []
    emitCloseBlock()
    const clientDefs = [...commandDefs.map(d => d.client), ...eventDefs.map(d => d.client)]
    emitInterface(`${domainName}Api`, clientDefs)
}

const getDomainDef = (domainName: string, $ref:string ) => {
    return {name: domainName, $ref: `${domainName}${$ref}`}
}

const getCommentLines = (description: string) => {
    const lines = description
        .replace(/<code>(.*)<\/code>/g, "'$1'")
        .split(/\r?\n/g)
        .map(line => ` * ${line}`)
    return [`/**`, ...lines, ,` */`]
}

const emitDescription = (description: string) => {
    description ? getCommentLines(description).map(l => emitLine(l)) : null
}

const getPropertyDef = (prop: P.ParameterType) => {
    if ((<any>prop).type == "function") {
        return `${prop.name}${getPropertyType(prop)}`
    } else  {
        return `${prop.name}${prop.optional ? '?' : ''}: ${getPropertyType(prop)}`
    }
}

const getPropertyType = (prop: any): string  => {
    if (prop.$ref)
        return prop.$ref
    else if (prop.type == 'array')
        return `${getPropertyType(prop.items)}[]`
    else if (prop.type == 'object')
        return `any`
    else if (prop.type == 'function')
        return `(${prop.accepts.map(getPropertyDef).join(', ')}): ${prop.returns || 'void'}`
    else if (prop.type == 'lambda')
        return `(${prop.accepts.map(getPropertyDef).join(', ')}) => ${prop.returns || 'void'}`
    else if (prop.type == 'string' && prop.enum)
        return '(' + prop.enum.map((v: string) => `'${v}'`).join(' | ') + ')'
    else if (prop.type == 'string' && prop.val)
        return `'${prop.val}'`
    return prop.type
}

const emitProperty = (prop: P.ParameterType, index: number, props:any[]) => {
    emitDescription(prop.description)
    emitLine(`${getPropertyDef(prop)};`)
    if (index < (props.length - 1)) {
        emitLine()
    }
}

const emitInterface = (interfaceName: string, props: ParamOrFunction[], emitNewLine = true): string => {
    emitNewLine ? emitLine() : null
    emitOpenBlock(`export interface ${interfaceName}`)
    props ? props.forEach(emitProperty) : emitLine('[key: string]: string;')
    emitCloseBlock()
    return interfaceName
}

const emitType = (type: P.PropertyType) => {
    emitLine()
    emitDescription(type.description)

    if (type.type === "object") {
        emitInterface(type.id, (<P.ObjectType & P.PropBaseType>type).properties, false)
    } else {
        emitLine(`export type ${type.id} = ${getPropertyType(type)};`)
    }
}

const toTitleCase = (str: string) => str[0].toUpperCase() + str.substr(1)

const emitCommand = (command: P.Command, domain: string): ClientDef => {
    const titleCase = toTitleCase(command.name)
    const requestType = command.parameters ? `${domain}.${emitInterface(`${titleCase}Request`, command.parameters)}` : null
    const responseType = command.returns ? `${domain}.${emitInterface(`${titleCase}Response`, command.returns)}` : null
    const paramsDef = requestType ? [{name: 'params', $ref: requestType}] : []
    const methodDef = [{name: 'method', $ref: `'${domain}.${command.name}'`}]

    const clientDef: P.FunctionType = {
        type: 'function',
        description: command.description,
        name: command.name,
        optional: false,
        accepts: paramsDef,
        returns: `Promise<${responseType || 'void'}>`
    }

    const commandDef: ClientDef = {
        name: command.name,
        client: clientDef,
    }

    return commandDef
}

const emitEvent = (event: P.Event, domain: string): ClientDef => {
    const titleCase = toTitleCase(event.name)
    const eventType = event.parameters ? `${domain}.${emitInterface(`${titleCase}Event`, event.parameters)}` : ''
    const paramsDef = eventType ? [{name: 'params', $ref: eventType}] : []

    const clientDef: P.FunctionType = {
        type: 'function',
        description: event.description,
        name: `on`,
        accepts: [
            {
                name: "event",
                type: "string",
                val: event.name,
            },
            {
                name: "listener",
                type: "lambda",
                accepts: paramsDef
            }
        ],
    }

    const eventDef: ClientDef = {
        name: event.name,
        client: clientDef,
    }

    return eventDef
}

const emitNames = (names: ClientDef[], arrayName: string) => {
    emitLine()
    emitOpenBlock(`export const ${arrayName}: string[] = `, '[')
    names.forEach(s => emitLine(`'${s.name}',`))
    emitCloseBlock(']')
}

/// Main
const destFilePath = `${__dirname}/../types/protocol.d.ts`
const moduleName = path.basename(destFilePath, ".d.ts")
const protocolDomains: P.Domain[] = jsProtocol.domains.concat(browserProtocol.domains)

emitModule(moduleName, protocolDomains)
console.log(`Writing to ${destFilePath}`)
fs.writeFileSync(destFilePath, emitStr, {encoding: 'utf-8'})
